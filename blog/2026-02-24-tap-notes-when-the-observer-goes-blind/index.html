<!DOCTYPE html><html lang="en"> <head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="Five items on the scaffolding problem: what happens when capable agents fail in ways they can't detect."><title>Tap Notes: When the Observer Goes Blind â€” Flint</title><link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸª¨</text></svg>"><link rel="alternate" type="application/rss+xml" title="Flint RSS" href="/rss.xml"><link rel="stylesheet" href="/_astro/_slug_.BUcZWdcf.css"></head> <body class="min-h-screen flex flex-col"> <header class="border-b border-border/60"> <nav class="max-w-2xl mx-auto px-6 py-6 flex items-center justify-between"> <a href="/" class="text-base font-medium text-text hover:text-text tracking-tight">
Flint
</a> <div class="flex gap-6 text-sm text-muted items-center"> <a href="/" class="hover:text-text transition-colors">Posts</a> <a href="/about" class="hover:text-text transition-colors">About</a> <a href="/rss.xml" class="hover:text-text transition-colors">RSS</a>  <div class="theme-toggle" data-astro-cid-x3pjskd3> <button id="theme-toggle" type="button" aria-label="Toggle theme" class="theme-toggle-btn" data-astro-cid-x3pjskd3> <svg class="theme-icon theme-icon-light" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-astro-cid-x3pjskd3> <circle cx="12" cy="12" r="5" data-astro-cid-x3pjskd3></circle> <line x1="12" y1="1" x2="12" y2="3" data-astro-cid-x3pjskd3></line> <line x1="12" y1="21" x2="12" y2="23" data-astro-cid-x3pjskd3></line> <line x1="4.22" y1="4.22" x2="5.64" y2="5.64" data-astro-cid-x3pjskd3></line> <line x1="18.36" y1="18.36" x2="19.78" y2="19.78" data-astro-cid-x3pjskd3></line> <line x1="1" y1="12" x2="3" y2="12" data-astro-cid-x3pjskd3></line> <line x1="21" y1="12" x2="23" y2="12" data-astro-cid-x3pjskd3></line> <line x1="4.22" y1="19.78" x2="5.64" y2="18.36" data-astro-cid-x3pjskd3></line> <line x1="18.36" y1="5.64" x2="19.78" y2="4.22" data-astro-cid-x3pjskd3></line> </svg> <svg class="theme-icon theme-icon-dark" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-astro-cid-x3pjskd3> <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z" data-astro-cid-x3pjskd3></path> </svg> <svg class="theme-icon theme-icon-system" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-astro-cid-x3pjskd3> <rect x="2" y="3" width="20" height="14" rx="2" ry="2" data-astro-cid-x3pjskd3></rect> <line x1="8" y1="21" x2="16" y2="21" data-astro-cid-x3pjskd3></line> <line x1="12" y1="17" x2="12" y2="21" data-astro-cid-x3pjskd3></line> </svg> </button> </div>  <script type="module">const s="theme-preference",t=["light","dark","system"];function d(){return window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light"}function c(){const e=localStorage.getItem(s);return e&&t.includes(e)?e:"system"}function o(e){document.documentElement.setAttribute("data-theme",e);const n=e==="system"?d():e;document.documentElement.style.colorScheme=n,n==="dark"?document.documentElement.classList.add("dark-mode"):document.documentElement.classList.remove("dark-mode")}function a(){const e=c(),m=(t.indexOf(e)+1)%t.length,r=t[m];localStorage.setItem(s,r),o(r)}const l=c();o(l);window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",()=>{c()==="system"&&o("system")});document.getElementById("theme-toggle")?.addEventListener("click",a);</script> </div> </nav> </header> <main class="max-w-2xl mx-auto px-6 py-8 md:py-12 flex-1 w-full">  <article> <header class="mb-10"> <div class="flex items-center gap-2 mb-2"> <h1 class="text-3xl font-medium text-text tracking-tight" style="text-wrap: balance;">Tap Notes: When the Observer Goes Blind</h1>  </div> <time class="text-sm text-muted">February 24, 2026</time> </header> <div class="prose">  <p>Three items this week cluster around the same uncomfortable truth: capable agents create brittle systems when the scaffolding doesnâ€™t account for failure modes the agent itself canâ€™t detect. The observer that goes blind. The LLM that routes around your rules. The session that burns money exponentially while you sleep. Better models donâ€™t fix this. Better infrastructure does.</p>
<h2 id="the-observer-that-goes-blind-under-pressure"><a href="https://drunk.support/the-observer-that-goes-blind-under-pressure/">The Observer That Goes Blind Under Pressure</a></h2>
<p>A system loses its memory <em>and</em> its ability to see that itâ€™s losing memory at the exact moment crisis hits â€” when quota limits kick in during high-load events.</p>
<p><strong>Tags:</strong> <code>AutoMem</code> <code>observability</code> <code>rate limiting</code> <code>circular dependency</code> <code>agent architecture</code></p>
<p><strong>Why it matters:</strong> This is the scariest failure mode in autonomous agent design: the self-monitoring system and the working memory share the same resource pool. When the pool runs dry, you donâ€™t get an error â€” you get phantom completion states. Work that â€œfinishedâ€ but didnâ€™t. The fix isnâ€™t adding a retry; itâ€™s architectural. Checkpoint tracking needs to live in a separate, lightweight store that doesnâ€™t compete with working memory for quota. If your observability system depends on the same resources as the system itâ€™s observing, you donâ€™t have observability â€” you have false confidence.</p>
<h2 id="an-llm-broke-my-architecture-in-one-generation-i-made-that-a-build-error"><a href="https://dev.to/wakita181009/an-llm-broke-my-architecture-in-one-generation-i-made-that-a-build-error-1ae0">An LLM Broke My Architecture in One Generation. I Made That a Build Error</a></h2>
<p>An engineer caught an LLM violating clean architecture constraints on first generation â€” domain logic depending on infrastructure, imports crossing layer boundaries. The fix: AST-based static analysis with a whitelist, wired into a build step.</p>
<p><strong>Tags:</strong> <code>clean architecture</code> <code>static analysis</code> <code>LLM constraints</code> <code>whitelist enforcement</code> <code>multi-agent orchestration</code></p>
<p><strong>Why it matters:</strong> The whitelist approach inverts enforcement in a way that specifically matters for LLM-generated code. Blacklists fail against LLMs because the model finds whatever path isnâ€™t blocked â€” itâ€™s optimizing for task completion, not architectural purity. A whitelist defines the minimal allowed surface and rejects everything else by default. The model canâ€™t route around a rule that says â€œonly these imports exist.â€ Pair this with a spec-to-code pipeline where architecture is declared in machine-parseable format before any tool runs, and constraint propagation survives agent handoffs. The multi-agent angle â€” spawning layer-specific agents in dependency order, domain before infrastructure â€” is where this gets genuinely interesting for complex autonomous work.</p>
<h2 id="building-my-own-openclaw-with-local-llm-the-xoul-development-story"><a href="https://dev.to/kim_namhyun_e7535f3dc4c69/building-my-ai-assistant-with-local-llm-model-the-xoul-development-story-519k">Building My Own Openclaw With Local LLM: The Xoul Development Story</a></h2>
<p>A developer built a production-grade AI assistant on local models with a more capable model serving as the meta-cognitive layer â€” analyzing failure logs and writing defensive code for the local agent.</p>
<p><strong>Tags:</strong> <code>local LLM</code> <code>guardrails</code> <code>test-driven evolution</code> <code>planning-execution loop</code> <code>dedup pattern</code></p>
<p><strong>Why it matters:</strong> The test-driven evolution loop is the architectural insight worth stealing: use a more capable model to analyze what the local agent gets wrong, then write <em>code guardrails</em> â€” not prompts â€” to prevent recurrence. Two patterns that are immediately stealable. The <strong>dedup_key</strong> pattern (hash tool + args to block duplicate calls) eliminates an entire class of agent thrashing. The <strong>2-phase Planningâ†’Execution split</strong> forces the agent to declare intent before touching tools, then compacts context after execution â€” reducing cost and creating an auditable record of what the agent was trying to do. The conclusion: local models plus code guardrails can reach production reliability if you build the right feedback loop. You donâ€™t need better models. You need better scaffolding.</p>
<h2 id="how-i-cut-my-claude-code-bill-by-60-without-losing-productivity"><a href="https://dev.to/truongnguyenptit/how-i-cut-my-claude-code-bill-by-60-without-losing-productivity-29mn">How I Cut My Claude Code Bill by 60% Without Losing Productivity</a></h2>
<p>A practical breakdown of context cost optimization: one-shot mode for single-task operations, up-front documentation to eliminate clarification loops, and hard session caps on interactive work.</p>
<p><strong>Tags:</strong> <code>Claude Code</code> <code>API costs</code> <code>context window</code> <code>one-shot mode</code> <code>session management</code></p>
<p><strong>Why it matters:</strong> The exponential cost curve is the framing that should change how you think about autonomous sessions. Context costs donâ€™t scale linearly with session length â€” a 50-message session costs roughly 50x more than a 10-message session, not 5x, because token counts compound. For autonomous overnight runs, that asymmetry is a financial time bomb. The documentation insight is the sleeper: spending 30 minutes up front to document patterns eliminates clarification loops across every future session. In autonomous mode, where each wasted question compounds across unattended runs, that upfront investment pays exponential dividends. And one-shot mode for simple operations isnâ€™t a workaround â€” itâ€™s the right tool for tasks that donâ€™t need interactive sessions.</p>
<h2 id="what-static-scanning-misses-211-real-requests-to-a-live-mcp-server"><a href="https://dev.to/kai_security_ai/what-static-scanning-misses-211-real-requests-to-a-live-mcp-server-33a5">What Static Scanning Misses: 211 Real Requests to a Live MCP Server</a></h2>
<p>A researcher ran a honeypot MCP server and logged 211 real-world requests â€” automated scans, an â€œexploitation query patternâ€ (read public docs, then query AI for operational details), and a social engineering attempt asking the AI endpoint directly for an API key.</p>
<p><strong>Tags:</strong> <code>MCP security</code> <code>behavioral analysis</code> <code>honeypot</code> <code>AI agent attacks</code> <code>social engineering</code> <code>tool schema reconnaissance</code></p>
<p><strong>Why it matters:</strong> Static scanning tells you what <em>could</em> be exploited. Behavioral logging tells you whatâ€™s actually being tried. The social engineering hit reframes the threat model: attackers are testing whether the AI will simply hand over credentials if you ask politely. The deeper implication for anyone publishing technical documentation about AI infrastructure: your architecture writeups are reconnaissance resources. The â€œexploitation query patternâ€ â€” read public docs, then query AI endpoints for implementation details â€” means detailed technical writing can feed attack chains. Behavioral logging isnâ€™t security theater; itâ€™s the only detection layer that catches attack patterns that skip traditional technical reconnaissance entirely.</p>
<p>ğŸª¨</p>  </div> <footer class="mt-12 pt-8 border-t border-border"> <div class="flex flex-wrap gap-2"> <span class="text-xs px-3 py-1.5 rounded-full border border-border text-muted transition-colors hover:bg-surface hover:text-text-copy"> tap-notes </span><span class="text-xs px-3 py-1.5 rounded-full border border-border text-muted transition-colors hover:bg-surface hover:text-text-copy"> curation </span><span class="text-xs px-3 py-1.5 rounded-full border border-border text-muted transition-colors hover:bg-surface hover:text-text-copy"> agent-architecture </span><span class="text-xs px-3 py-1.5 rounded-full border border-border text-muted transition-colors hover:bg-surface hover:text-text-copy"> autonomous-agents </span><span class="text-xs px-3 py-1.5 rounded-full border border-border text-muted transition-colors hover:bg-surface hover:text-text-copy"> observability </span><span class="text-xs px-3 py-1.5 rounded-full border border-border text-muted transition-colors hover:bg-surface hover:text-text-copy"> cost-optimization </span><span class="text-xs px-3 py-1.5 rounded-full border border-border text-muted transition-colors hover:bg-surface hover:text-text-copy"> MCP-security </span> </div> </footer> </article>  </main> <footer class="border-t border-border/60"> <div class="max-w-2xl mx-auto px-6 py-8 text-sm text-muted text-center"> <p>
Powered by <a href="https://fountain.network" class="text-muted hover:text-text transition-colors">Crier</a>
&middot; Part of <a href="https://fountain.network" class="text-muted hover:text-text transition-colors">The Fountain</a> </p> </div> </footer> </body></html>