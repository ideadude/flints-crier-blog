<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>indigo empire</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body { width: 100%; height: 100%; background: #000; overflow: hidden; }
canvas#glc { display: block; width: 100%; height: 100%; position: fixed; top: 0; left: 0; z-index: 1; }
canvas#ptc { display: block; width: 100%; height: 100%; position: fixed; top: 0; left: 0;
             mix-blend-mode: screen; pointer-events: none; z-index: 2; }

#ui {
  position: fixed; top: 0; right: 0;
  font-family: 'Courier New', monospace; font-size: 11px;
  z-index: 10; user-select: none;
}
#toggle-btn {
  display: block; padding: 7px 12px;
  background: rgba(4,1,20,0.88);
  border: 1px solid rgba(90,40,200,0.35);
  border-top: none; border-right: none;
  color: #6858a0; cursor: pointer; letter-spacing: 0.12em;
  font-family: inherit; font-size: inherit;
}
#toggle-btn:hover { color: #b0a0e0; border-color: rgba(140,70,255,0.55); }
#panel {
  display: none; background: rgba(4,1,20,0.94);
  border-left: 1px solid rgba(70,30,160,0.4);
  border-bottom: 1px solid rgba(70,30,160,0.4);
  padding: 14px 15px; width: 205px;
  max-height: calc(100vh - 32px); overflow-y: auto;
}
#panel.open { display: block; }
.row { margin-bottom: 12px; }
.lbl { display: flex; justify-content: space-between; margin-bottom: 4px; }
.lbl-text { color: #5c4e88; letter-spacing: 0.07em; }
.lbl-val  { color: #a090d0; }
.section-divider {
  border: none; border-top: 1px solid rgba(70,30,160,0.25);
  margin: 14px 0 14px;
}
input[type=range] { width: 100%; accent-color: #6020c0; cursor: pointer; }
select {
  width: 100%; background: rgba(6,2,28,0.95); color: #7060a0;
  border: 1px solid rgba(70,30,160,0.4);
  font-family: 'Courier New', monospace; font-size: 11px; padding: 4px 3px; margin-top: 3px;
}
.pal-strip { display: flex; gap: 3px; flex-wrap: wrap; margin-top: 6px; }
.pal-swatch { width: 28px; height: 12px; cursor: pointer; border: 1px solid transparent; }
.pal-swatch.on { border-color: rgba(200,180,255,0.85); }
.section-title {
  color: #9080c8; letter-spacing: 0.18em; font-size: 10px;
  margin-bottom: 14px; text-transform: uppercase; opacity: 0.7;
}
.sub-title {
  color: #7060a0; letter-spacing: 0.12em; font-size: 9px;
  margin-bottom: 10px; margin-top: 4px; text-transform: uppercase; opacity: 0.6;
}
#share-btn {
  display: block; width: 100%; padding: 7px 0; margin-top: 6px;
  background: rgba(30,10,80,0.5); color: #7868a8;
  border: 1px solid rgba(90,40,200,0.3);
  font-family: 'Courier New', monospace; font-size: 11px;
  letter-spacing: 0.12em; cursor: pointer;
}
#share-btn:hover { color: #c0b0ff; border-color: rgba(140,70,255,0.55); background: rgba(55,20,130,0.5); }
#hint {
  position: fixed; bottom: 12px; left: 14px;
  font-family: 'Courier New', monospace; font-size: 10px;
  color: rgba(100,80,180,0.38); pointer-events: none; letter-spacing: 0.06em;
  z-index: 10;
}
</style>
</head>
<body>
<canvas id="glc"></canvas>
<canvas id="ptc"></canvas>

<div id="ui">
  <button id="toggle-btn">⚙ settings</button>
  <div id="panel">
    <div class="section-title">Indigo Empire v5</div>

    <!-- Field -->
    <div class="row">
      <div class="lbl"><span class="lbl-text">LAYERS</span><span class="lbl-val" id="v-layers">4</span></div>
      <input type="range" id="s-layers" min="2" max="6" value="4" step="1">
    </div>
    <div class="row">
      <div class="lbl"><span class="lbl-text">SPEED</span><span class="lbl-val" id="v-speed">0.50</span></div>
      <input type="range" id="s-speed" min="0.05" max="2.0" value="0.5" step="0.05">
    </div>
    <div class="row">
      <div class="lbl"><span class="lbl-text">DISTORTION</span><span class="lbl-val" id="v-distort">0.65</span></div>
      <input type="range" id="s-distort" min="0" max="2.5" value="0.65" step="0.05">
    </div>
    <div class="row">
      <div class="lbl"><span class="lbl-text">SCALE</span><span class="lbl-val" id="v-scale">1.0</span></div>
      <input type="range" id="s-scale" min="0.3" max="3.0" value="1.0" step="0.1">
    </div>
    <div class="row">
      <div class="lbl"><span class="lbl-text">GLOW</span><span class="lbl-val" id="v-bright">1.10</span></div>
      <input type="range" id="s-bright" min="0.3" max="2.5" value="1.1" step="0.05">
    </div>
    <div class="row">
      <div class="lbl"><span class="lbl-text">BLOOM</span><span class="lbl-val" id="v-bloom">0.55</span></div>
      <input type="range" id="s-bloom" min="0" max="1.5" value="0.55" step="0.05">
    </div>
    <div class="row">
      <div class="lbl"><span class="lbl-text">CONFLUENCE</span><span class="lbl-val" id="v-confluent">0.60</span></div>
      <input type="range" id="s-confluent" min="0" max="2.0" value="0.6" step="0.05">
    </div>
    <div class="row">
      <div class="lbl"><span class="lbl-text">BREATH</span><span class="lbl-val" id="v-breath">0.30</span></div>
      <input type="range" id="s-breath" min="0" max="1.0" value="0.3" step="0.05">
    </div>
    <div class="row">
      <div class="lbl"><span class="lbl-text">SWEEP</span><span class="lbl-val" id="v-sweep">0.40</span></div>
      <input type="range" id="s-sweep" min="0" max="1.2" value="0.4" step="0.05">
    </div>
    <div class="row">
      <div class="lbl"><span class="lbl-text">WARP SPIN</span><span class="lbl-val" id="v-warpspin">1.00</span></div>
      <input type="range" id="s-warpspin" min="0" max="5.0" value="1.0" step="0.1">
    </div>
    <div class="row">
      <div class="lbl"><span class="lbl-text">HOLE PULL</span><span class="lbl-val" id="v-pull">0.20</span></div>
      <input type="range" id="s-pull" min="0" max="1.0" value="0.2" step="0.02">
    </div>
    <div class="row">
      <div class="lbl"><span class="lbl-text">CHROMA</span><span class="lbl-val" id="v-chroma">0.30</span></div>
      <input type="range" id="s-chroma" min="0" max="1.0" value="0.3" step="0.02">
    </div>
    <div class="row">
      <div class="lbl"><span class="lbl-text">PARTICLES</span><span class="lbl-val" id="v-particles">0.60</span></div>
      <input type="range" id="s-particles" min="0" max="1.0" value="0.6" step="0.05">
    </div>
    <div class="row">
      <div class="lbl"><span class="lbl-text">FIELD TYPE</span></div>
      <select id="s-field">
        <option value="0">ripple rings</option>
        <option value="1">crystal facets</option>
        <option value="2">archimedean spiral</option>
        <option value="3">vortex twist</option>
        <option value="4">flower petals</option>
        <option value="5">lattice interference</option>
      </select>
    </div>
    <div class="row">
      <div class="lbl"><span class="lbl-text">PALETTE</span></div>
      <div class="pal-strip" id="pal-strip"></div>
    </div>

    <hr class="section-divider">
    <div class="sub-title">Halftone / Print Layer</div>

    <div class="row">
      <div class="lbl"><span class="lbl-text">HALFTONE</span><span class="lbl-val" id="v-halftone">0.00</span></div>
      <input type="range" id="s-halftone" min="0" max="1.0" value="0.0" step="0.02">
    </div>
    <div class="row">
      <div class="lbl"><span class="lbl-text">DOT SIZE</span><span class="lbl-val" id="v-dotsize">8</span></div>
      <input type="range" id="s-dotsize" min="2" max="24" value="8" step="1">
    </div>
    <div class="row">
      <div class="lbl"><span class="lbl-text">MODE</span></div>
      <select id="s-htmode">
        <option value="0">halftone dots</option>
        <option value="1">grain dither</option>
        <option value="2">scanlines</option>
      </select>
    </div>
    <button id="share-btn">⇧ share settings</button>
  </div>
</div>

<div id="hint">hold · drag to warp · release for ripple</div>

<script>
// ─────────────────────────────────────────────────────────────
// WebGL init
// ─────────────────────────────────────────────────────────────
const canvas = document.getElementById('glc');
const gl = canvas.getContext('webgl', { antialias: false, alpha: false });
if (!gl) {
  document.body.innerHTML = '<p style="color:#f55;font-family:monospace;padding:20px">WebGL required</p>';
  throw new Error('WebGL not supported');
}

// ─────────────────────────────────────────────────────────────
// Scene shader
// ─────────────────────────────────────────────────────────────
const SCENE_VS = `attribute vec2 aPos; void main() { gl_Position = vec4(aPos, 0.0, 1.0); }`;

const SCENE_FS = `
precision highp float;

uniform vec2  uRes;
uniform float uTime;
uniform float uSpeed;
uniform float uDistort;
uniform float uScale;
uniform float uBright;
uniform float uConfluent;
uniform float uBreath;
uniform float uSweep;
uniform float uWarpSpd;
uniform int   uField;
uniform vec2  uMouse;
uniform float uMouseDown;
uniform float uPull;
uniform float uRipple;
uniform float uRippleX;
uniform float uRippleY;

uniform float uFreqs[6];
uniform float uPhases[6];
uniform vec2  uDrifts[6];
uniform vec4  uColors[6];
uniform float uDistStr[6];
uniform float uSweepFreq[6];
uniform float uSweepPhase[6];

// ── Field functions ───────────────────────────────────────────

float ripple(vec2 p, float ph) {
  float a = sin(p.x + cos(p.y * 0.72 + ph) * 2.2)
          * cos(p.y + sin(p.x * 0.72 + ph * 1.13) * 2.2);
  float b = sin(length(p) * 0.85 - ph);
  return a * 0.55 + b * 0.45;
}

float crystal(vec2 p, float ph) {
  float r = length(p);
  float a = atan(p.y, p.x);
  return sin(r * 2.5 - ph) * cos(a * 5.0 + ph * 0.65) * 0.65
       + sin(p.x * 1.9 + ph * 0.85) * sin(p.y * 1.9 - ph * 0.8) * 0.35;
}

float spiral(vec2 p, float ph) {
  float r = length(p);
  float a = atan(p.y, p.x);
  return sin(r * 2.8 - a * 3.5 - ph) * 0.6
       + cos(p.x * 0.9 + cos(p.y * 0.9 + ph) * 1.9) * 0.4;
}

float vortex(vec2 p, float ph) {
  float r = length(p);
  float twist = atan(p.y, p.x) + r * 1.6 + ph * 0.3;
  return sin(twist * 2.5 + ph) * 0.55 + sin(r * 3.5 - ph * 1.25) * 0.45;
}

float flower(vec2 p, float ph) {
  float r = length(p);
  float a = atan(p.y, p.x);
  float petals = cos(a * 3.0 + ph) * cos(a * 2.0 - ph * 0.7);
  float bloom  = sin(r * 3.5 - ph * 1.1) * cos(r * 1.4 + ph * 0.6);
  float cross  = sin(petals * 3.14 + bloom * 2.0 + ph * 0.5);
  return petals * 0.4 + bloom * 0.3 + cross * 0.3;
}

float lattice(vec2 p, float ph) {
  float a0 = p.x * 2.1 + p.y * 0.7 + ph;
  float a1 = p.x * 0.7 - p.y * 2.1 - ph * 1.13;
  float a2 = p.x * 1.6 + p.y * 1.6 + ph * 0.77;
  float grid = sin(a0) * sin(a1) * 0.5 + sin(a2) * sin(a0 - a1) * 0.3;
  float ring = sin(length(p) * 2.4 - ph * 0.9) * 0.2;
  return grid + ring;
}

float evalField(vec2 p, float ph) {
  if (uField == 1) return crystal(p, ph);
  if (uField == 2) return spiral(p, ph);
  if (uField == 3) return vortex(p, ph);
  if (uField == 4) return flower(p, ph);
  if (uField == 5) return lattice(p, ph);
  return ripple(p, ph);
}

vec2 rot2(vec2 v, float angle) {
  float c = cos(angle); float s = sin(angle);
  return vec2(v.x * c - v.y * s, v.x * s + v.y * c);
}

// ── Main ─────────────────────────────────────────────────────
void main() {
  vec2 uv = (gl_FragCoord.xy - uRes * 0.5) / uRes.y;

  float breathCycle = 1.0 + uBreath * 0.08 * sin(uTime * uSpeed * 0.4);
  uv *= breathCycle;

  vec2 toMouse = uv - uMouse * vec2(uRes.x / uRes.y, 1.0) * 0.5;
  float mDist  = length(toMouse) + 0.001;
  float pullAmt = uPull * (0.15 + uMouseDown * 0.3);
  uv += normalize(toMouse) * pullAmt / (mDist * 5.0 + 1.0);

  if (uRipple > 0.0) {
    vec2 ripC  = vec2(uRippleX, uRippleY) * vec2(uRes.x / uRes.y, 1.0) * 0.5;
    float rD   = length(uv - ripC);
    float rFront = uRipple * 0.9;
    float rW   = 0.07;
    float rAmt = smoothstep(rW, 0.0, abs(rD - rFront)) * (1.0 - uRipple);
    uv += normalize(uv - ripC + vec2(0.001)) * rAmt * 0.07;
  }

  vec3 accum    = vec3(0.0);
  vec2 warp     = vec2(0.0);
  float peakSum = 0.0;
  float warpRotAngle = uTime * uSpeed * 0.08 * uWarpSpd;

  for (int i = 0; i < 6; i++) {
    vec4 col = uColors[i];
    if (col.a >= 0.01) {
      float iF   = float(i);
      float layerBreath = 1.0 + uBreath * 0.05
                        * sin(uTime * uSpeed * (0.28 + iF * 0.07));

      float sweepAngle = uSweep * sin(uTime * uSpeed * uSweepFreq[i] + uSweepPhase[i]);
      vec2 drift = rot2(uDrifts[i], sweepAngle);

      vec2 rotWarp = rot2(warp, warpRotAngle);
      if (i == 1 || i == 3 || i == 5) {
        rotWarp = rot2(rotWarp, 1.5708);
      }

      vec2 su = uv * layerBreath + rotWarp * uDistStr[i] * uDistort * 0.085;
      vec2 p  = su * uFreqs[i] * uScale * 3.2 + drift * uTime * uSpeed;
      float ph = uPhases[i] + uTime * uSpeed * uFreqs[i] * 0.38;

      float v         = evalField(p, ph);
      float intensity = (v + 1.0) * 0.5;

      float thresh = 0.26;
      float a = max(0.0, (intensity - thresh) / (1.0 - thresh));
      a = pow(a, 1.28) * col.a * uBright;

      peakSum += a;
      accum = 1.0 - (1.0 - accum) * (1.0 - col.rgb * a);

      float warpAngle = ph + v * 3.14159 + iF * 0.95;
      warp += vec2(sin(warpAngle), cos(warpAngle)) * a * 1.4;
    }
  }

  if (uConfluent > 0.01 && peakSum > 1.4) {
    float cStrength = smoothstep(1.4, 3.0, peakSum) * uConfluent;
    float fx = uv.x * 892.3 + uv.y * 473.1 + uTime * 8.0;
    float fy = uv.x * 631.7 - uv.y * 1237.4 + uTime * 11.3;
    float shimmer = pow(0.5 + 0.5 * sin(fx) * cos(fy), 6.0) * cStrength;
    accum = 1.0 - (1.0 - accum) * (1.0 - vec3(1.0, 0.95, 0.88) * shimmer);
  }

  float vig = 1.0 - smoothstep(0.52, 1.4, length(uv) * 1.08);
  accum *= vig;

  gl_FragColor = vec4(accum, 1.0);
}
`;

// ─────────────────────────────────────────────────────────────
// Bloom + post-process shader (v5: adds halftone/dither layer)
// ─────────────────────────────────────────────────────────────
const BLOOM_VS = `
  attribute vec2 aPos;
  varying vec2 vUV;
  void main() { vUV = aPos * 0.5 + 0.5; gl_Position = vec4(aPos, 0.0, 1.0); }
`;

const BLOOM_FS = `
  precision mediump float;
  varying vec2 vUV;
  uniform sampler2D uScene;
  uniform vec2  uTexel;
  uniform float uBloom;
  uniform float uChroma;
  uniform vec2  uMouse;
  uniform float uHalftone;   // 0=off, 1=full effect
  uniform float uDotSize;    // pixels per grid cell
  uniform int   uHalftoneMode; // 0=dots, 1=grain dither, 2=scanlines

  void main() {
    // Chromatic aberration
    vec2 center = vec2(0.5, 0.5);
    vec2 toCenter = vUV - center;
    float distC = length(toCenter);
    vec2 mouseSS = uMouse * 0.5 + 0.5;
    float mDist = length(vUV - mouseSS);
    float extraAberr = uChroma * 0.006 * smoothstep(0.25, 0.0, mDist);
    float aberrStr = uChroma * 0.003 * distC + extraAberr;
    vec2 aberrOff = normalize(toCenter + vec2(0.001)) * aberrStr;

    float rVal = texture2D(uScene, vUV + aberrOff).r;
    float gVal = texture2D(uScene, vUV).g;
    float bVal = texture2D(uScene, vUV - aberrOff).b;
    vec3 sharp  = vec3(rVal, gVal, bVal);

    // Bloom
    float r1 = uTexel.x * 4.0;
    vec3 b1 = vec3(0.0);
    b1 += texture2D(uScene, vUV + vec2( r1,  0.0)).rgb;
    b1 += texture2D(uScene, vUV + vec2(-r1,  0.0)).rgb;
    b1 += texture2D(uScene, vUV + vec2( 0.0,  r1)).rgb;
    b1 += texture2D(uScene, vUV + vec2( 0.0, -r1)).rgb;
    b1 += texture2D(uScene, vUV + vec2( r1*0.707,  r1*0.707)).rgb;
    b1 += texture2D(uScene, vUV + vec2(-r1*0.707,  r1*0.707)).rgb;
    b1 += texture2D(uScene, vUV + vec2( r1*0.707, -r1*0.707)).rgb;
    b1 += texture2D(uScene, vUV + vec2(-r1*0.707, -r1*0.707)).rgb;
    b1 /= 8.0;

    float r2 = uTexel.x * 20.0;
    vec3 b2 = vec3(0.0);
    b2 += texture2D(uScene, vUV + vec2( r2, 0.0)).rgb;
    b2 += texture2D(uScene, vUV + vec2(-r2, 0.0)).rgb;
    b2 += texture2D(uScene, vUV + vec2(0.0,  r2)).rgb;
    b2 += texture2D(uScene, vUV + vec2(0.0, -r2)).rgb;
    b2 /= 4.0;

    vec3 result = sharp
                + max(b1 - 0.2, vec3(0.0)) * uBloom * 1.5
                + max(b2 - 0.1, vec3(0.0)) * uBloom * 0.6;

    // Warm tone in highlights (TeamLab)
    float lum0 = dot(result, vec3(0.299, 0.587, 0.114));
    result += vec3(0.05, -0.01, -0.05) * smoothstep(0.35, 1.0, lum0);
    result = clamp(result, 0.0, 1.0);

    // ── Halftone / dithering overlay ─────────────────────────
    // Applied after bloom so the effect is clean and crisp.
    // Three modes share the same uDotSize control for consistent
    // feel — turning the knob always makes the grain coarser.
    if (uHalftone > 0.01) {
      float lum = dot(result, vec3(0.299, 0.587, 0.114));
      lum = clamp(lum, 0.0, 1.0);
      float mask = 1.0;

      if (uHalftoneMode == 0) {
        // ── Halftone dots at 45° ────────────────────────────
        // Classic offset-printing angle. Each grid cell contains
        // a circular dot whose radius scales with sqrt(luminance),
        // so area (brightness) is perceptually proportional.
        float ca = 0.7071; float sa = 0.7071; // cos/sin(45°)
        vec2 fc  = gl_FragCoord.xy;
        vec2 rot = vec2(fc.x * ca - fc.y * sa, fc.x * sa + fc.y * ca);
        // local position within cell, normalized [-1, 1]
        vec2 cell  = rot / uDotSize;
        vec2 local = (fract(cell) - 0.5) * 2.0;
        float dotR = sqrt(lum) * 1.05;
        mask = step(length(local), dotR);

      } else if (uHalftoneMode == 1) {
        // ── Grain dither ────────────────────────────────────
        // Interleaved gradient noise — low-discrepancy, no grid
        // artifacts, similar to blue noise dithering.
        // Cell size controlled by uDotSize for chunky vs fine grain.
        vec2 dPos = floor(gl_FragCoord.xy / uDotSize);
        float noise = fract(52.9829189 * fract(dot(dPos, vec2(0.06711056, 0.00583715))));
        mask = step(noise, lum);

      } else {
        // ── Scanlines ───────────────────────────────────────
        // Horizontal bands. uDotSize controls line spacing.
        // At dotSize=1: every other pixel (tight TV scan)
        // At dotSize=4: visible CRT-style bands
        // At dotSize=12: bold editorial stripes
        mask = mod(floor(gl_FragCoord.y / uDotSize), 2.0);
      }

      // The halftone mask is binary (0 or 1). We preserve hue from
      // the original result — the mask just controls light vs dark,
      // not color. Gives a posterized/printed feel especially with
      // the monochrome palette.
      vec3 htResult = result * mask;
      result = mix(result, htResult, uHalftone);
    }

    gl_FragColor = vec4(result, 1.0);
  }
`;

// ─────────────────────────────────────────────────────────────
// Compile / link
// ─────────────────────────────────────────────────────────────
function compileShader(src, type) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
    console.error('Shader error:', gl.getShaderInfoLog(s));
    return null;
  }
  return s;
}
function linkProgram(vsrc, fsrc) {
  const vs = compileShader(vsrc, gl.VERTEX_SHADER);
  const fs = compileShader(fsrc, gl.FRAGMENT_SHADER);
  if (!vs || !fs) return null;
  const p = gl.createProgram();
  gl.attachShader(p, vs);
  gl.attachShader(p, fs);
  gl.linkProgram(p);
  if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
    console.error('Link error:', gl.getProgramInfoLog(p));
    return null;
  }
  return p;
}

const sceneProg = linkProgram(SCENE_VS, SCENE_FS);
const bloomProg = linkProgram(BLOOM_VS, BLOOM_FS);
if (!sceneProg || !bloomProg) throw new Error('Shader compilation failed');

const quadBuf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, quadBuf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);

function bindQuad(prog) {
  gl.bindBuffer(gl.ARRAY_BUFFER, quadBuf);
  const loc = gl.getAttribLocation(prog, 'aPos');
  gl.enableVertexAttribArray(loc);
  gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);
}

// ─────────────────────────────────────────────────────────────
// FBO
// ─────────────────────────────────────────────────────────────
let fbo, fboTex;
function createFBO(w, h) {
  if (fboTex) gl.deleteTexture(fboTex);
  if (fbo)    gl.deleteFramebuffer(fbo);
  fboTex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, fboTex);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  fbo = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, fboTex, 0);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
}

// ─────────────────────────────────────────────────────────────
// Uniforms
// ─────────────────────────────────────────────────────────────
function uniLoc(prog, names) {
  const L = {};
  names.forEach(n => { L[n] = gl.getUniformLocation(prog, n); });
  return L;
}
const sU = uniLoc(sceneProg, [
  'uRes','uTime','uSpeed','uDistort','uScale','uBright',
  'uConfluent','uBreath','uSweep','uWarpSpd',
  'uField','uMouse','uMouseDown','uPull','uRipple','uRippleX','uRippleY',
  'uFreqs','uPhases','uDrifts','uColors','uDistStr','uSweepFreq','uSweepPhase',
]);
const bU = uniLoc(bloomProg, [
  'uScene','uTexel','uBloom','uChroma','uMouse',
  'uHalftone','uDotSize','uHalftoneMode',
]);

// ─────────────────────────────────────────────────────────────
// Palettes
// ─────────────────────────────────────────────────────────────
const PALETTES = [
  // 0: Indigo Empire
  [[0.04,0.20,0.92,0.82],[0.55,0.03,0.96,0.75],[0.94,0.03,0.60,0.68],
   [0.00,0.85,0.96,0.62],[0.97,0.78,0.04,0.55],[0.26,0.00,0.72,0.78]],
  // 1: Bioluminescence
  [[0.00,0.90,0.74,0.80],[0.06,0.64,0.98,0.74],[0.34,0.94,0.64,0.68],
   [0.70,0.14,0.98,0.62],[0.90,0.90,0.26,0.52],[0.00,0.34,0.84,0.78]],
  // 2: Ember Field
  [[0.98,0.30,0.03,0.80],[0.86,0.68,0.00,0.74],[0.86,0.03,0.20,0.68],
   [1.00,0.50,0.06,0.62],[0.54,0.06,0.00,0.85],[0.98,0.90,0.30,0.58]],
  // 3: Void Garden
  [[0.10,0.03,0.54,0.90],[0.36,0.07,0.65,0.74],[0.03,0.36,0.65,0.68],
   [0.65,0.03,0.44,0.62],[0.03,0.54,0.48,0.58],[0.54,0.54,0.65,0.52]],
  // 4: Sakura Night
  [[0.96,0.50,0.65,0.80],[0.82,0.14,0.42,0.75],[0.96,0.80,0.22,0.65],
   [0.50,0.04,0.64,0.72],[0.96,0.82,0.86,0.58],[0.28,0.00,0.30,0.88]],
  // 5: Monochrome — pure luminance layers, no saturation.
  // Screen-blended grays produce a clean white-on-black interference
  // field. Pair with halftone overlay for a print/engraving aesthetic.
  // Six tones from near-black to white give full tonal range.
  [[1.00,1.00,1.00,0.78],[0.78,0.78,0.78,0.72],[0.52,0.52,0.52,0.68],
   [0.32,0.32,0.32,0.80],[0.88,0.86,0.84,0.60],[0.08,0.08,0.10,0.90]],
];

// ─────────────────────────────────────────────────────────────
// Layers
// ─────────────────────────────────────────────────────────────
const LAYERS = [
  { freq:1.000, dA:0.000, dSpd:0.24, phase:0.000, dStr:0.0, swFreq:0.31, swPh:0.00 },
  { freq:1.618, dA:1.047, dSpd:0.18, phase:1.047, dStr:0.9, swFreq:0.47, swPh:1.57 },
  { freq:2.414, dA:2.094, dSpd:0.15, phase:2.094, dStr:1.6, swFreq:0.23, swPh:3.14 },
  { freq:1.732, dA:3.141, dSpd:0.21, phase:3.141, dStr:2.0, swFreq:0.61, swPh:0.79 },
  { freq:3.146, dA:4.189, dSpd:0.12, phase:4.189, dStr:2.4, swFreq:0.19, swPh:2.36 },
  { freq:2.236, dA:5.236, dSpd:0.17, phase:5.236, dStr:2.8, swFreq:0.53, swPh:4.71 },
];

// ─────────────────────────────────────────────────────────────
// Config
// ─────────────────────────────────────────────────────────────
const cfg = {
  layers:4, speed:0.5, distort:0.65, scale:1.0, bright:1.1,
  bloom:0.55, confluent:0.6, breath:0.3, sweep:0.4, warpspin:1.0,
  pull:0.2, chroma:0.3, particles:0.6, field:0, palette:0,
  halftone:0.0, dotsize:8, htmode:0,
};

// ─────────────────────────────────────────────────────────────
// Resize
// ─────────────────────────────────────────────────────────────
const ptCanvas = document.getElementById('ptc');
const p2d      = ptCanvas.getContext('2d');

function resize() {
  canvas.width    = window.innerWidth;
  canvas.height   = window.innerHeight;
  ptCanvas.width  = window.innerWidth;
  ptCanvas.height = window.innerHeight;
  gl.viewport(0, 0, canvas.width, canvas.height);
  createFBO(canvas.width, canvas.height);
}
resize();
window.addEventListener('resize', resize);

// ─────────────────────────────────────────────────────────────
// Mouse / touch
// ─────────────────────────────────────────────────────────────
const mouse  = { x: 0, y: 0, down: 0 };
const ripple = { t: -1.0, x: 0, y: 0 };

function setMouse(x, y) {
  mouse.x =  (x / window.innerWidth)  * 2 - 1;
  mouse.y = -((y / window.innerHeight) * 2 - 1);
}
window.addEventListener('mousemove',  e => setMouse(e.clientX, e.clientY));
window.addEventListener('mousedown',  e => { mouse.down = 1; setMouse(e.clientX, e.clientY); });
window.addEventListener('mouseup',    () => {
  if (mouse.down) { ripple.t = 0; ripple.x = mouse.x; ripple.y = mouse.y; }
  mouse.down = 0;
});
window.addEventListener('touchmove', e => {
  e.preventDefault();
  setMouse(e.touches[0].clientX, e.touches[0].clientY);
  mouse.down = 1;
}, { passive: false });
window.addEventListener('touchstart', e => {
  setMouse(e.touches[0].clientX, e.touches[0].clientY);
  mouse.down = 1;
});
window.addEventListener('touchend', () => {
  ripple.t = 0; ripple.x = mouse.x; ripple.y = mouse.y;
  mouse.down = 0;
});

// ─────────────────────────────────────────────────────────────
// Palette crossfade
// ─────────────────────────────────────────────────────────────
let palCurrent = PALETTES[0].map(c => [...c]);

function lerpPal(dt) {
  const target = PALETTES[cfg.palette];
  const k = Math.min(dt * 2.2, 1.0);
  for (let i = 0; i < 6; i++)
    for (let j = 0; j < 4; j++)
      palCurrent[i][j] += (target[i][j] - palCurrent[i][j]) * k;
  return palCurrent;
}

// ─────────────────────────────────────────────────────────────
// Particle system
// ─────────────────────────────────────────────────────────────
const MAX_PARTICLES = 65;
const particles = [];

function mkParticle() {
  const li    = Math.floor(Math.random() * cfg.layers);
  const layer = LAYERS[li];
  const c     = palCurrent[li];
  const ang   = layer.dA + (Math.random() - 0.5) * 1.2;
  const spd   = (layer.dSpd * 55 + Math.random() * 25) * (0.4 + cfg.speed * 0.6);
  const m = 0.15;
  return {
    x: ptCanvas.width  * (m + Math.random() * (1 - 2 * m)),
    y: ptCanvas.height * (m + Math.random() * (1 - 2 * m)),
    vx: Math.cos(ang) * spd,
    vy: -Math.sin(ang) * spd,
    t:  Math.random(),
    dur: 3.5 + Math.random() * 5.5,
    sz: 1.8 + Math.random() * 4.2,
    r: c[0], g: c[1], b: c[2],
  };
}

function tickParticles(dt) {
  if (cfg.particles < 0.01) { p2d.clearRect(0, 0, ptCanvas.width, ptCanvas.height); return; }
  const count = Math.round(MAX_PARTICLES * cfg.particles);
  while (particles.length < count) particles.push(mkParticle());

  p2d.clearRect(0, 0, ptCanvas.width, ptCanvas.height);

  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.t += dt / p.dur;
    if (p.t >= 1.0 || p.x < -60 || p.x > ptCanvas.width + 60
                    || p.y < -60 || p.y > ptCanvas.height + 60) {
      particles[i] = mkParticle(); continue;
    }
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    const alpha = Math.min(p.t * 4, 1.0) * Math.min((1.0 - p.t) * 4, 1.0) * cfg.particles;
    if (alpha < 0.01) continue;
    const r8 = Math.round(p.r * 255), g8 = Math.round(p.g * 255), b8 = Math.round(p.b * 255);
    const hr = p.sz * 4.5;
    const gr = p2d.createRadialGradient(p.x, p.y, 0, p.x, p.y, hr);
    gr.addColorStop(0,          `rgba(${r8},${g8},${b8},${alpha})`);
    gr.addColorStop(p.sz / hr,  `rgba(${r8},${g8},${b8},${(alpha * 0.55).toFixed(3)})`);
    gr.addColorStop(1,          `rgba(${r8},${g8},${b8},0)`);
    p2d.beginPath();
    p2d.arc(p.x, p.y, hr, 0, Math.PI * 2);
    p2d.fillStyle = gr;
    p2d.fill();
  }
}

// ─────────────────────────────────────────────────────────────
// Render loop
// ─────────────────────────────────────────────────────────────
const t0 = performance.now();
let lastNow = t0;

function render(now) {
  requestAnimationFrame(render);
  const dt = Math.min((now - lastNow) / 1000, 0.05);
  lastNow  = now;
  const t  = (now - t0) / 1000;

  if (ripple.t >= 0) { ripple.t += dt * 0.55; if (ripple.t > 1.0) ripple.t = -1.0; }

  const pal      = lerpPal(dt);
  const freqs    = LAYERS.map(l => l.freq);
  const phases   = LAYERS.map(l => l.phase);
  const drifts   = LAYERS.flatMap(l => [Math.cos(l.dA) * l.dSpd, Math.sin(l.dA) * l.dSpd]);
  const colors   = pal.flatMap((c, i) => (i < cfg.layers ? c : [0, 0, 0, 0]));
  const distStr  = LAYERS.map(l => l.dStr);
  const swFreq   = LAYERS.map(l => l.swFreq);
  const swPhase  = LAYERS.map(l => l.swPh);

  // Pass 1: scene → FBO
  gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
  gl.useProgram(sceneProg);
  bindQuad(sceneProg);
  gl.uniform2f(sU.uRes,        canvas.width, canvas.height);
  gl.uniform1f(sU.uTime,       t);
  gl.uniform1f(sU.uSpeed,      cfg.speed);
  gl.uniform1f(sU.uDistort,    cfg.distort);
  gl.uniform1f(sU.uScale,      cfg.scale);
  gl.uniform1f(sU.uBright,     cfg.bright);
  gl.uniform1f(sU.uConfluent,  cfg.confluent);
  gl.uniform1f(sU.uBreath,     cfg.breath);
  gl.uniform1f(sU.uSweep,      cfg.sweep);
  gl.uniform1f(sU.uWarpSpd,    cfg.warpspin);
  gl.uniform1i(sU.uField,      cfg.field);
  gl.uniform2f(sU.uMouse,      mouse.x, mouse.y);
  gl.uniform1f(sU.uMouseDown,  mouse.down);
  gl.uniform1f(sU.uPull,       cfg.pull);
  gl.uniform1f(sU.uRipple,     ripple.t);
  gl.uniform1f(sU.uRippleX,    ripple.x);
  gl.uniform1f(sU.uRippleY,    ripple.y);
  gl.uniform1fv(sU.uFreqs,     freqs);
  gl.uniform1fv(sU.uPhases,    phases);
  gl.uniform2fv(sU.uDrifts,    drifts);
  gl.uniform4fv(sU.uColors,    colors);
  gl.uniform1fv(sU.uDistStr,   distStr);
  gl.uniform1fv(sU.uSweepFreq, swFreq);
  gl.uniform1fv(sU.uSweepPhase, swPhase);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

  // Pass 2: bloom + halftone → screen
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.useProgram(bloomProg);
  bindQuad(bloomProg);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, fboTex);
  gl.uniform1i(bU.uScene,        0);
  gl.uniform2f(bU.uTexel,        1.0 / canvas.width, 1.0 / canvas.height);
  gl.uniform1f(bU.uBloom,        cfg.bloom);
  gl.uniform1f(bU.uChroma,       cfg.chroma);
  gl.uniform2f(bU.uMouse,        mouse.x, mouse.y);
  gl.uniform1f(bU.uHalftone,     cfg.halftone);
  gl.uniform1f(bU.uDotSize,      cfg.dotsize);
  gl.uniform1i(bU.uHalftoneMode, cfg.htmode);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

  // Pass 3: particle overlay
  tickParticles(dt);
}

requestAnimationFrame(render);

// ─────────────────────────────────────────────────────────────
// Settings UI
// ─────────────────────────────────────────────────────────────
document.getElementById('toggle-btn').addEventListener('click', () => {
  document.getElementById('panel').classList.toggle('open');
});

function bindRange(id, key, parse, dec) {
  const sl = document.getElementById('s-' + id);
  const vl = document.getElementById('v-' + id);
  sl.addEventListener('input', () => {
    const val = parse ? parse(sl.value) : parseFloat(sl.value);
    cfg[key] = val;
    vl.textContent = dec != null ? val.toFixed(dec) : String(val);
  });
}

bindRange('layers',    'layers',    parseInt, 0);
bindRange('speed',     'speed',     null, 2);
bindRange('distort',   'distort',   null, 2);
bindRange('scale',     'scale',     null, 1);
bindRange('bright',    'bright',    null, 2);
bindRange('bloom',     'bloom',     null, 2);
bindRange('confluent', 'confluent', null, 2);
bindRange('breath',    'breath',    null, 2);
bindRange('sweep',     'sweep',     null, 2);
bindRange('warpspin',  'warpspin',  null, 2);
bindRange('pull',      'pull',      null, 2);
bindRange('chroma',    'chroma',    null, 2);
bindRange('particles', 'particles', null, 2);
bindRange('halftone',  'halftone',  null, 2);
bindRange('dotsize',   'dotsize',   parseInt, 0);

document.getElementById('s-field').addEventListener('change', e => {
  cfg.field = parseInt(e.target.value);
});
document.getElementById('s-htmode').addEventListener('change', e => {
  cfg.htmode = parseInt(e.target.value);
});

// Palette swatches
const palStrip = document.getElementById('pal-strip');
const palNames = ['Indigo Empire','Bioluminescence','Ember Field','Void Garden','Sakura Night','Monochrome'];
PALETTES.forEach((pal, pi) => {
  const sw = document.createElement('canvas');
  sw.width = 28; sw.height = 12;
  sw.className = 'pal-swatch' + (pi === 0 ? ' on' : '');
  sw.title = palNames[pi];
  const sc = sw.getContext('2d');
  pal.forEach((c, ci) => {
    sc.fillStyle = `rgb(${Math.round(c[0]*255)},${Math.round(c[1]*255)},${Math.round(c[2]*255)})`;
    sc.fillRect(Math.round(ci * 28 / 6), 0, Math.ceil(28 / 6), 12);
  });
  sw.addEventListener('click', () => {
    document.querySelectorAll('.pal-swatch').forEach(s => s.classList.remove('on'));
    sw.classList.add('on');
    cfg.palette = pi;
  });
  palStrip.appendChild(sw);
});

// ─────────────────────────────────────────────────────────────
// URL sharing — encode all settings into the hash so a link
// restores the exact visual state
// ─────────────────────────────────────────────────────────────
const CFG_KEYS = [
  'layers','speed','distort','scale','bright','bloom','confluent','breath',
  'sweep','warpspin','pull','chroma','particles','field','palette',
  'halftone','dotsize','htmode',
];
const INT_KEYS = new Set(['layers','field','palette','dotsize','htmode']);

function encodeURL() {
  const p = new URLSearchParams();
  CFG_KEYS.forEach(k => p.set(k, cfg[k]));
  return location.origin + location.pathname + '#' + p.toString();
}

function loadFromURL() {
  if (!location.hash || location.hash.length < 2) return;
  const p = new URLSearchParams(location.hash.slice(1));
  CFG_KEYS.forEach(k => {
    if (p.has(k)) cfg[k] = INT_KEYS.has(k) ? parseInt(p.get(k)) : parseFloat(p.get(k));
  });
}

function syncUIFromCfg() {
  // Fire 'input' events so existing bindRange handlers update both
  // the slider position and the displayed value label
  ['layers','speed','distort','scale','bright','bloom','confluent','breath',
   'sweep','warpspin','pull','chroma','particles','halftone','dotsize'].forEach(id => {
    const sl = document.getElementById('s-' + id);
    if (sl) { sl.value = cfg[id]; sl.dispatchEvent(new Event('input')); }
  });
  document.getElementById('s-field').value = cfg.field;
  document.getElementById('s-field').dispatchEvent(new Event('change'));
  document.getElementById('s-htmode').value = cfg.htmode;
  document.getElementById('s-htmode').dispatchEvent(new Event('change'));
  document.querySelectorAll('.pal-swatch').forEach((sw, i) => sw.classList.toggle('on', i === cfg.palette));
  // Skip crossfade on initial load — jump straight to the saved palette
  palCurrent = PALETTES[cfg.palette].map(c => [...c]);
}

document.getElementById('share-btn').addEventListener('click', () => {
  const url = encodeURL();
  const btn = document.getElementById('share-btn');
  const reset = () => { btn.textContent = '⇧ share settings'; };

  // Use clipboard API if available, otherwise fall back to execCommand
  const copied = () => { btn.textContent = '✓ copied!'; setTimeout(reset, 1800); };
  if (navigator.clipboard) {
    navigator.clipboard.writeText(url).then(copied).catch(() => {
      prompt('Copy this link:', url);
    });
  } else {
    const ta = Object.assign(document.createElement('textarea'),
      { value: url, style: 'position:fixed;opacity:0' });
    document.body.appendChild(ta);
    ta.select();
    document.execCommand('copy');
    document.body.removeChild(ta);
    copied();
  }
});

// Apply URL state on load (runs after all listeners are attached)
loadFromURL();
syncUIFromCfg();
</script>
</body>
</html>
